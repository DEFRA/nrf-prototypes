{% extends "govuk-prototype-kit/layouts/govuk-branded.njk" %} {% set
pageName="Draw a red line boundary" %} {% block pageTitle %} Draw a red line
boundary - {% if data.journeyType === 'payment' %}Pay for Nature Restoration
Fund Levy{% else %}Get an estimate for Nature Restoration Fund Levy{% endif %} -
GOV.UK {% endblock %} {% block head %} {{ super() }}
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"
/>
<style>
  /* Accessible map interface layout - GOV.UK compliant */
  .map-interface {
    display: flex;
    gap: 30px;
    margin-bottom: 30px;
  }

  .map-controls-panel {
    width: 300px;
    background: #f3f2f1;
    border: 1px solid #b1b4b6;
    padding: 20px;
    flex-shrink: 0;
  }

  /* Typography following GOV.UK design system */
  .map-controls-panel h2 {
    font-family: 'GDS Transport', arial, sans-serif;
    font-size: 19px;
    line-height: 1.31579;
    font-weight: 700;
    margin-top: 0;
    margin-bottom: 15px;
    color: #0b0c0c;
  }

  .map-controls-panel h3 {
    font-family: 'GDS Transport', arial, sans-serif;
    font-size: 16px;
    line-height: 1.25;
    font-weight: 700;
    margin-top: 20px;
    margin-bottom: 10px;
    color: #0b0c0c;
  }

  .map-controls-panel h3:first-of-type {
    margin-top: 0;
  }

  .search-container {
    display: flex;
    gap: 10px;
    align-items: flex-end;
  }

  .search-container .govuk-input {
    flex: 1;
  }

  .search-button {
    flex-shrink: 0;
    margin-bottom: 0;
  }

  /* GOV.UK link styling for tool links */
  .tool-links {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  /* Disabled state for tool links */
  .tool-links .govuk-link[aria-disabled='true'] {
    color: #505a5f;
    cursor: not-allowed;
    text-decoration: none;
  }

  .tool-links .govuk-link[aria-disabled='true']:hover {
    color: #505a5f;
    text-decoration: none;
  }

  .tool-links .govuk-link[aria-disabled='true']:focus {
    outline: 3px solid #ffdd00;
    outline-offset: 0;
    background-color: #ffdd00;
    color: #0b0c0c;
  }

  /* Destructive action styling */
  .tool-links .govuk-link--destructive {
    color: #d4351c;
  }

  .tool-links .govuk-link--destructive:hover {
    color: #a52814;
    text-decoration-thickness: max(3px, 0.1875rem, 0.12em);
  }

  .tool-links .govuk-link--destructive:focus {
    color: #0b0c0c;
    background-color: #ffdd00;
  }

  .map-controls-panel .govuk-hint {
    font-family: 'GDS Transport', arial, sans-serif;
    font-size: 16px;
    line-height: 1.25;
    margin-top: 5px;
    margin-bottom: 10px;
    color: #505a5f;
  }

  .map-controls-panel .govuk-form-group {
    margin-bottom: 20px;
  }

  .map-controls-panel .govuk-form-group:last-child {
    margin-bottom: 0;
  }

  .map-container {
    position: relative;
    flex: 1;
    min-height: 500px;
  }

  #map {
    height: 500px;
    width: 100%;
    border: 1px solid #b1b4b6;
  }

  /* Hide the default Leaflet draw toolbar since we're using our own controls */
  .leaflet-draw-toolbar {
    display: none !important;
  }

  /* Responsive design for smaller screens - GOV.UK compliant */
  @media (max-width: 768px) {
    .map-interface {
      flex-direction: column;
      gap: 20px;
    }

    .map-controls-panel {
      width: 100%;
      padding: 15px;
    }

    .search-container {
      flex-direction: column;
      align-items: stretch;
      gap: 15px;
    }

    .search-button {
      margin-top: 0;
    }
  }
</style>
{% endblock %} {% block content %}
<div class="govuk-grid-row">
  <div class="govuk-grid-column-full">
    <a href="{{ backLink }}" class="govuk-back-link">Back</a>

    <form id="map-form" action="/nrf-estimate-1/map" method="post" novalidate>
      <input
        type="hidden"
        name="navFromSummary"
        value="{{ 'true' if navFromSummary else 'false' }}"
      />

      {% if error %}
      <div
        class="govuk-error-summary"
        aria-labelledby="error-summary-title"
        role="alert"
      >
        <h2 class="govuk-error-summary__title" id="error-summary-title">
          There is a problem
        </h2>
        <div class="govuk-error-summary__body">
          <ul class="govuk-list govuk-error-summary__list">
            <li>
              <a href="#map">{{ error }}</a>
            </li>
          </ul>
        </div>
      </div>
      {% endif %}

      <div
        id="client-error-summary"
        class="govuk-error-summary"
        aria-labelledby="error-summary-title"
        role="alert"
        style="display: none"
      >
        <h2 class="govuk-error-summary__title" id="error-summary-title">
          There is a problem
        </h2>
        <div class="govuk-error-summary__body">
          <ul class="govuk-list govuk-error-summary__list">
            <li>
              <a href="#map" id="client-error-link"></a>
            </li>
          </ul>
        </div>
      </div>

      <div
        class="govuk-form-group {% if error %}govuk-form-group--error{% endif %}"
      >
        <h1 class="govuk-label-wrapper">
          <label class="govuk-label govuk-label--l" for="map">
            Draw a red line boundary
          </label>
        </h1>

        <div id="map-hint" class="govuk-hint">
          <p class="govuk-body">
            Use the map to draw a red line boundary for where the development
            might be.
          </p>
        </div>

        {% if error %}
        <p id="map-error" class="govuk-error-message">
          <span class="govuk-visually-hidden">Error:</span> {{ error }}
        </p>
        {% endif %}

        <!-- Accessible map interface with left panel -->
        <div class="map-interface">
          <!-- Left control panel -->
          <div class="map-controls-panel">
            <!-- Search functionality -->
            <div class="govuk-form-group">
              <label class="govuk-label" for="location-search">
                Search for a location
              </label>
              <div class="search-container">
                <input
                  class="govuk-input"
                  id="location-search"
                  name="location-search"
                  type="text"
                  placeholder="Enter postcode, town or area"
                />
              </div>
            </div>

            <hr
              class="govuk-section-break govuk-section-break--m govuk-section-break--visible"
            />

            <!-- Drawing tools -->
            <div class="govuk-form-group">
              <h2 class="govuk-heading-s">Drawing tools</h2>
              <div class="tool-links">
                <a
                  href="#"
                  class="govuk-link"
                  id="start-drawing"
                  data-tool="polygon"
                  aria-describedby="drawing-instructions"
                  tabindex="0"
                >
                  Start drawing boundary
                </a>
                <a
                  href="#"
                  class="govuk-link"
                  id="edit-boundary"
                  data-tool="edit"
                  aria-describedby="edit-instructions"
                  tabindex="-1"
                  aria-disabled="true"
                >
                  Edit boundary
                </a>
                <a
                  href="#"
                  class="govuk-link govuk-link--destructive"
                  id="delete-boundary"
                  data-tool="delete"
                  aria-describedby="delete-instructions"
                  tabindex="-1"
                  aria-disabled="true"
                >
                  Delete boundary
                </a>
              </div>
            </div>

            <hr
              class="govuk-section-break govuk-section-break--m govuk-section-break--visible"
            />

            <!-- Map controls -->
            <div class="govuk-form-group">
              <h2 class="govuk-heading-s">Map view</h2>
              <div class="tool-links">
                <a
                  href="#"
                  class="govuk-link"
                  id="zoom-to-england"
                  aria-describedby="zoom-england-help"
                  role="button"
                  tabindex="0"
                >
                  Show all England
                </a>
                <a
                  href="#"
                  class="govuk-link"
                  id="zoom-to-boundary"
                  aria-describedby="zoom-boundary-help"
                  tabindex="-1"
                  aria-disabled="true"
                >
                  Zoom to boundary
                </a>
                <a
                  href="#"
                  class="govuk-link"
                  id="toggle-catchments"
                  aria-describedby="toggle-catchments-help"
                  tabindex="0"
                >
                  Toggle catchments
                </a>
              </div>
            </div>
          </div>

          <!-- Map container -->
          <div class="map-container">
            <div
              id="map"
              role="img"
              aria-label="Interactive map for drawing development boundary"
            >
              <div
                id="map-loading"
                style="
                  text-align: center;
                  padding: 2rem;
                  background: #f8f8f8;
                  border: 1px solid #ccc;
                "
              >
                <p class="govuk-body">Loading map...</p>
              </div>
            </div>
          </div>
        </div>

        <input
          type="hidden"
          id="boundary-data"
          name="boundary-data"
          value="{{ existingBoundaryData }}"
        />
      </div>

      <button class="govuk-button" type="submit">Continue</button>
    </form>
  </div>
</div>

<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script>
  // Initialize map after page is fully loaded
  ;(function () {
    'use strict'

    let isDrawing = false
    let isEditing = false

    // Wait for everything to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initMap)
    } else {
      initMap()
    }

    function showErrorSummary(message) {
      const errorSummary = document.getElementById('client-error-summary')
      const errorLink = document.getElementById('client-error-link')

      if (errorSummary && errorLink) {
        errorLink.textContent = message
        errorSummary.style.display = 'block'
        errorSummary.scrollIntoView({ behavior: 'smooth', block: 'start' })
        errorSummary.focus()
      }
    }

    function hideErrorSummary() {
      const errorSummary = document.getElementById('client-error-summary')
      if (errorSummary) {
        errorSummary.style.display = 'none'
      }
    }

    function initMap() {
      // Additional delay to ensure GOV.UK components are ready
      setTimeout(function () {
        console.log('Map script loading...')
        console.log('Leaflet available:', typeof L !== 'undefined')
        console.log(
          'Map container exists:',
          document.getElementById('map') !== null
        )

        // Check if Leaflet is loaded
        if (typeof L === 'undefined') {
          console.error('Leaflet library not loaded')
          const loadingDiv = document.getElementById('map-loading')
          if (loadingDiv) {
            loadingDiv.style.display = 'none'
          }
          showErrorSummary(
            'The map library failed to load. Please refresh the page to try again.'
          )
          return
        }

        // Check if map container exists
        const mapContainer = document.getElementById('map')
        if (!mapContainer) {
          console.error('Map container not found')
          showErrorSummary(
            'The map container could not be found. Please refresh the page to try again.'
          )
          return
        }

        try {
          // Hide loading message
          const loadingDiv = document.getElementById('map-loading')
          if (loadingDiv) {
            loadingDiv.style.display = 'none'
          }

          // Initialize the map centered on England
          const map = L.map('map').setView([52.5, -1.5], 6)
          console.log('Map initialized')

          // Add OpenStreetMap tiles
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
          }).addTo(map)
          console.log('Tiles added')

          // Load GeoJSON boundaries
          let edpBoundaries = []
          let edpLayers = []

          // Color palette for different catchments
          const colors = [
            '#ff6b6b',
            '#4ecdc4',
            '#45b7d1',
            '#96ceb4',
            '#feca57',
            '#ff9ff3',
            '#a8e6cf',
            '#dda0dd',
            '#ffa726',
            '#ab47bc',
            '#26a69a',
            '#42a5f5',
            '#66bb6a',
            '#ef5350',
            '#ff7043',
            '#8d6e63'
          ]

          // Load GeoJSON data
          console.log('=== STARTING GEOJSON LOAD ===')
          fetch('/nrf-estimate-1/catchments.geojson')
            .then((response) => {
              console.log('Fetch response status:', response.status)
              console.log('Fetch response ok:', response.ok)
              return response.json()
            })
            .then((data) => {
              console.log('GeoJSON data loaded successfully')
              console.log(
                'Number of features:',
                data.features ? data.features.length : 'undefined'
              )
              console.log(
                'First feature:',
                data.features ? data.features[0] : 'undefined'
              )

              // Process each feature in the GeoJSON
              data.features.forEach((feature, index) => {
                const properties = feature.properties
                const geometry = feature.geometry

                // Extract catchment name from properties
                const catchmentName =
                  properties.Label ||
                  properties.N2K_Site_N ||
                  `Catchment ${index + 1}`
                const color = colors[index % colors.length]

                // Convert GeoJSON coordinates to Leaflet format
                if (geometry.type === 'Polygon') {
                  const coordinates = geometry.coordinates[0].map((coord) => [
                    coord[1],
                    coord[0]
                  ]) // Convert [lng, lat] to [lat, lng]

                  // Debug logging for first few catchments
                  if (index < 3) {
                    console.log(`Catchment ${index + 1} (${catchmentName}):`)
                    console.log(
                      '  Original GeoJSON coords (first 3):',
                      geometry.coordinates[0].slice(0, 3)
                    )
                    console.log(
                      '  Converted Leaflet coords (first 3):',
                      coordinates.slice(0, 3)
                    )
                    console.log('  Coordinate count:', coordinates.length)
                  }

                  const polygon = L.polygon(coordinates, {
                    color: color,
                    weight: 2,
                    opacity: 0.8,
                    fillColor: color,
                    fillOpacity: 0.3
                  }).addTo(map)

                  // Add popup with catchment information
                  const popupContent = `
                                        <strong>${catchmentName}</strong><br>
                                        ${properties.PopupInfo ? `Type: ${properties.PopupInfo}<br>` : ''}
                                        ${properties.DateAmend ? `Last Updated: ${properties.DateAmend}<br>` : ''}
                                        ${properties.Notes ? `Notes: ${properties.Notes}` : ''}
                                    `
                  polygon.bindPopup(popupContent)

                  edpLayers.push({
                    name: catchmentName,
                    polygon: polygon,
                    coordinates: coordinates,
                    properties: properties
                  })

                  edpBoundaries.push({
                    name: catchmentName,
                    color: color,
                    coordinates: coordinates
                  })
                }
              })

              console.log('Catchment boundaries added:', edpLayers.length)

              // Test intersection function with a simple case
              if (edpLayers.length > 0) {
                console.log('=== TESTING INTERSECTION FUNCTION ===')
                const testPolygon1 = [
                  [-2.9, 52.2],
                  [-2.8, 52.2],
                  [-2.8, 52.3],
                  [-2.9, 52.3],
                  [-2.9, 52.2]
                ]
                const testPolygon2 = [
                  [-2.85, 52.25],
                  [-2.75, 52.25],
                  [-2.75, 52.35],
                  [-2.85, 52.35],
                  [-2.85, 52.25]
                ]
                const testResult = polygonIntersects(testPolygon1, testPolygon2)
                console.log('Test intersection result:', testResult)

                // Test with actual catchment coordinates if available
                if (edpLayers.length > 0) {
                  console.log('Testing with actual catchment data...')
                  const firstCatchment = edpLayers[0]
                  console.log('First catchment name:', firstCatchment.name)
                  console.log(
                    'First catchment coords (first 3):',
                    firstCatchment.coordinates.slice(0, 3)
                  )

                  // Create a test polygon that should intersect with the first catchment
                  const testDrawnPolygon = firstCatchment.coordinates.slice(
                    0,
                    4
                  ) // Use first 4 points of catchment
                  const testResult2 = polygonIntersects(
                    testDrawnPolygon,
                    firstCatchment.coordinates
                  )
                  console.log(
                    'Test with actual catchment data result:',
                    testResult2
                  )

                  // Test with coordinates from your drawn area (Salisbury area based on screenshot)
                  const testPolygon3 = [
                    [-1.9, 51.2],
                    [-1.8, 51.2],
                    [-1.8, 51.3],
                    [-1.9, 51.3],
                    [-1.9, 51.2]
                  ]
                  console.log(
                    'Testing with coordinates from drawn area:',
                    testPolygon3
                  )
                  const testResult3 = polygonIntersects(
                    testPolygon3,
                    firstCatchment.coordinates
                  )
                  console.log(
                    'Test with drawn area coordinates result:',
                    testResult3
                  )

                  // Test with a polygon that should definitely intersect (using catchment's own coordinates)
                  const testPolygon4 = firstCatchment.coordinates
                    .slice(0, 3)
                    .concat([firstCatchment.coordinates[0]]) // Triangle inside catchment
                  console.log(
                    'Testing with triangle inside catchment:',
                    testPolygon4
                  )
                  const testResult4 = polygonIntersects(
                    testPolygon4,
                    firstCatchment.coordinates
                  )
                  console.log(
                    'Test with triangle inside catchment result:',
                    testResult4
                  )
                }

                console.log('=== END TEST ===')

                // Re-check any existing drawn polygons for intersections
                console.log(
                  'Re-checking existing drawn polygons for intersections...'
                )
                drawnItems.eachLayer(function (layer) {
                  if (layer instanceof L.Polygon) {
                    console.log(
                      'Re-checking existing polygon for intersections'
                    )
                    const drawnPolygon = layer.getLatLngs()[0]
                    const drawnPoints = drawnPolygon.map((latLng) => [
                      latLng.lng,
                      latLng.lat
                    ])

                    let intersectingCatchment = null
                    edpLayers.forEach((catchment) => {
                      if (
                        polygonIntersects(drawnPoints, catchment.coordinates)
                      ) {
                        intersectingCatchment = catchment
                        console.log(
                          `Found intersection with existing polygon: ${catchment.name}`
                        )
                      }
                    })

                    updateBoundaryData(layer, intersectingCatchment)
                  }
                })
              }

              // Only fit map to catchments if no existing boundary is loaded
              if (edpLayers.length > 0 && !existingBoundaryData) {
                const group = new L.featureGroup(
                  edpLayers.map((edp) => edp.polygon)
                )
                map.fitBounds(group.getBounds().pad(0.1))
                console.log('Map fitted to show catchment boundaries')
              } else if (edpLayers.length > 0 && existingBoundaryData) {
                console.log(
                  'Catchments loaded but keeping focus on existing boundary'
                )
              }
            })
            .catch((error) => {
              console.error('=== GEOJSON LOAD ERROR ===')
              console.error('Error loading GeoJSON data:', error)
              console.error('Error message:', error.message)
              console.error('Error stack:', error.stack)
              console.log('Falling back to hardcoded boundaries')
              console.log('=== END GEOJSON LOAD ERROR ===')

              showErrorSummary(
                'Catchment data is temporarily unavailable. You can still draw a boundary, but catchment information will not be shown.'
              )
            })

          // Initialize the draw control (hidden, we'll use our own controls)
          const drawnItems = new L.FeatureGroup()
          map.addLayer(drawnItems)

          // Create draw control but don't add it to map (we'll control it programmatically)
          const drawControl = new L.Control.Draw({
            position: 'topleft',
            draw: {
              polygon: {
                allowIntersection: false,
                showArea: true,
                showLength: true,
                metric: true,
                feet: false,
                nautic: false,
                drawError: {
                  color: '#e1e100',
                  message: '<strong>Error:</strong> shape edges cannot cross!'
                },
                shapeOptions: {
                  color: '#d4351c',
                  weight: 3,
                  opacity: 0.8,
                  fillColor: '#d4351c',
                  fillOpacity: 0.2
                }
              },
              polyline: false,
              rectangle: false,
              circle: false,
              marker: false,
              circlemarker: false
            },
            edit: {
              featureGroup: drawnItems,
              remove: true
            }
          })

          // Add the control to the map but hide it
          map.addControl(drawControl)

          // Hide the toolbar after it's added
          setTimeout(() => {
            const toolbar = document.querySelector('.leaflet-draw-toolbar')
            if (toolbar) {
              toolbar.style.display = 'none'
            }
          }, 100)

          console.log('Draw control created and added to map')

          // Add a simple click handler to test if events are working
          map.on('click', function (e) {
            console.log('Map clicked at:', e.latlng)
          })

          // Load existing boundary data if available
          const existingBoundaryData =
            document.getElementById('boundary-data').value
          console.log('Raw boundary data from input:', existingBoundaryData)

          if (existingBoundaryData) {
            try {
              const boundaryData = JSON.parse(existingBoundaryData)
              console.log('Parsed boundary data:', boundaryData)
              console.log('Coordinates:', boundaryData.coordinates)
              console.log('Coordinates type:', typeof boundaryData.coordinates)
              console.log('Is array:', Array.isArray(boundaryData.coordinates))

              // Check if coordinates exist and convert to Leaflet format
              if (
                boundaryData.coordinates &&
                Array.isArray(boundaryData.coordinates) &&
                boundaryData.coordinates.length > 0
              ) {
                console.log('Processing coordinates...')
                const latLngs = boundaryData.coordinates.map((point) => [
                  point[1],
                  point[0]
                ]) // Convert [lng, lat] to [lat, lng]
                console.log('Converted latLngs:', latLngs)

                // Create and add the existing polygon
                const existingPolygon = L.polygon(latLngs, {
                  color: '#d4351c',
                  weight: 3,
                  opacity: 0.8,
                  fillColor: '#d4351c',
                  fillOpacity: 0.2
                })

                drawnItems.addLayer(existingPolygon)

                // Always fit map to show the existing boundary when it exists
                map.fitBounds(existingPolygon.getBounds().pad(0.1))
                console.log('Map focused on existing boundary')

                console.log(
                  'Existing boundary loaded and displayed successfully'
                )
              } else {
                console.log(
                  'No valid coordinates found in boundary data. Coordinates:',
                  boundaryData.coordinates
                )
              }
            } catch (error) {
              console.error('Error loading existing boundary:', error)
              console.error(
                'Raw data that failed to parse:',
                existingBoundaryData
              )
            }
          } else {
            console.log('No existing boundary data found')
          }

          document
            .querySelector('form')
            .addEventListener('submit', function (e) {
              if (isDrawing) {
                e.preventDefault()
                showErrorSummary(
                  'You are still drawing the boundary. Select "Cancel drawing" or finish drawing before continuing.'
                )
                return false
              }

              if (isEditing) {
                e.preventDefault()
                showErrorSummary(
                  'You are still editing the boundary. Select "Stop editing" before continuing.'
                )
                return false
              }

              const boundaryData =
                document.getElementById('boundary-data').value
              if (!boundaryData) {
                e.preventDefault()
                showErrorSummary(
                  'Please draw a boundary on the map before continuing.'
                )
                return false
              }

              hideErrorSummary()

              // Check for nav=summary query parameter
              const urlParams = new URLSearchParams(window.location.search)
              const navParam = urlParams.get('nav')

              if (navParam === 'summary') {
                console.log('Navigation parameter detected: summary')

                try {
                  const parsedData = JSON.parse(boundaryData)
                  const hasIntersection =
                    parsedData.intersectingCatchment !== null

                  console.log('Intersection status:', hasIntersection)
                  console.log(
                    'Intersecting catchment:',
                    parsedData.intersectingCatchment
                  )

                  if (hasIntersection) {
                    // Redirect to summary page if there's an intersection
                    console.log('Redirecting to summary page')
                    e.preventDefault()
                    window.location.href = '/nrf-estimate-1/summary'
                    return false
                  } else {
                    // Let the form submit normally to go to no-edp page
                    console.log(
                      'No intersection found, submitting form normally'
                    )
                  }
                } catch (error) {
                  console.error(
                    'Error parsing boundary data for navigation:',
                    error
                  )
                  // Let the form submit normally if there's an error
                }
              }
            })

          // Initialize accessible controls with a delay to ensure draw control is ready
          setTimeout(() => {
            // Check if DOM is ready and all required objects exist
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', () => {
                if (map && drawControl && drawnItems) {
                  initAccessibleControls(
                    map,
                    drawControl,
                    drawnItems,
                    edpLayers
                  )
                } else {
                  console.error(
                    'Required objects not available for initialization'
                  )
                }
              })
            } else {
              if (map && drawControl && drawnItems) {
                initAccessibleControls(map, drawControl, drawnItems, edpLayers)
              } else {
                console.error(
                  'Required objects not available for initialization'
                )
              }
            }
          }, 500)

          console.log('Map setup complete')
        } catch (error) {
          console.error('Error initializing map:', error)
          const loadingDiv = document.getElementById('map-loading')
          if (loadingDiv) {
            loadingDiv.style.display = 'none'
          }
          showErrorSummary(
            'There was a problem loading the map. Please refresh the page to try again.'
          )
        }
      }, 1000) // Increased delay to ensure GOV.UK components are ready
    }

    // Helper function to check if two line segments intersect
    function lineSegmentsIntersect(p1, q1, p2, q2) {
      function orientation(p, q, r) {
        const val =
          (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
        if (val === 0) return 0 // collinear
        return val > 0 ? 1 : 2 // clockwise or counterclockwise
      }

      function onSegment(p, q, r) {
        return (
          q[0] <= Math.max(p[0], r[0]) &&
          q[0] >= Math.min(p[0], r[0]) &&
          q[1] <= Math.max(p[1], r[1]) &&
          q[1] >= Math.min(p[1], r[1])
        )
      }

      const o1 = orientation(p1, q1, p2)
      const o2 = orientation(p1, q1, q2)
      const o3 = orientation(p2, q2, p1)
      const o4 = orientation(p2, q2, q1)

      // General case
      if (o1 !== o2 && o3 !== o4) return true

      // Special cases
      if (o1 === 0 && onSegment(p1, p2, q1)) return true
      if (o2 === 0 && onSegment(p1, q2, q1)) return true
      if (o3 === 0 && onSegment(p2, p1, q2)) return true
      if (o4 === 0 && onSegment(p2, q1, q2)) return true

      return false
    }

    // Helper functions for polygon intersection detection
    function isPointInPolygon(point, polygon) {
      const x = point[0],
        y = point[1] // point is [lng, lat]

      let inside = false
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        // polygon coordinates are [lng, lat] format
        const xi = polygon[i][0],
          yi = polygon[i][1] // [lng, lat]
        const xj = polygon[j][0],
          yj = polygon[j][1] // [lng, lat]
        if (yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi) {
          inside = !inside
        }
      }
      return inside
    }

    function polygonIntersects(polygon1, polygon2) {
      // polygon1 is drawn polygon in [lng, lat] format
      // polygon2 is catchment polygon in [lat, lng] format (from Leaflet)
      // Convert polygon2 from [lat, lng] to [lng, lat] format for comparison
      const poly2 = polygon2.map((coord) => [coord[1], coord[0]])

      console.log('Intersection check:')
      console.log('  Drawn polygon (first 3 points):', polygon1.slice(0, 3))
      console.log('  Catchment polygon (first 3 points):', poly2.slice(0, 3))

      // Quick check: if polygons have very different bounding boxes, they likely don't intersect
      const bounds1 = getPolygonBounds(polygon1)
      const bounds2 = getPolygonBounds(poly2)
      console.log('  Bounds1:', bounds1)
      console.log('  Bounds2:', bounds2)
      console.log('  Bounds overlap:', boundsOverlap(bounds1, bounds2))

      if (!boundsOverlap(bounds1, bounds2)) {
        console.log('  No intersection: bounding boxes do not overlap')
        return false
      }

      // Check if any vertex of polygon1 is inside polygon2
      for (let i = 0; i < polygon1.length; i++) {
        if (isPointInPolygon(polygon1[i], poly2)) {
          console.log(
            `  Intersection found: vertex ${i} of drawn polygon is inside catchment`
          )
          return true
        }
      }

      // Check if any vertex of polygon2 is inside polygon1
      for (let i = 0; i < poly2.length; i++) {
        if (isPointInPolygon(poly2[i], polygon1)) {
          console.log(
            `  Intersection found: vertex ${i} of catchment is inside drawn polygon`
          )
          return true
        }
      }

      // Check center point of polygon1
      const centerLng =
        polygon1.reduce((sum, coord) => sum + coord[0], 0) / polygon1.length
      const centerLat =
        polygon1.reduce((sum, coord) => sum + coord[1], 0) / polygon1.length
      if (isPointInPolygon([centerLng, centerLat], poly2)) {
        console.log(
          '  Intersection found: center of drawn polygon is inside catchment'
        )
        return true
      }

      // Check for edge intersections between the two polygons
      for (let i = 0; i < polygon1.length; i++) {
        const p1 = polygon1[i]
        const q1 = polygon1[(i + 1) % polygon1.length]

        for (let j = 0; j < poly2.length; j++) {
          const p2 = poly2[j]
          const q2 = poly2[(j + 1) % poly2.length]

          if (lineSegmentsIntersect(p1, q1, p2, q2)) {
            console.log(
              `  Intersection found: edge intersection between drawn polygon edge ${i} and catchment edge ${j}`
            )
            return true
          }
        }
      }

      console.log('  No intersection detected')
      return false
    }

    // Helper function to get polygon bounding box
    function getPolygonBounds(polygon) {
      let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity
      for (const point of polygon) {
        minX = Math.min(minX, point[0])
        minY = Math.min(minY, point[1])
        maxX = Math.max(maxX, point[0])
        maxY = Math.max(maxY, point[1])
      }
      return { minX, minY, maxX, maxY }
    }

    // Helper function to check if two bounding boxes overlap
    function boundsOverlap(bounds1, bounds2) {
      return !(
        bounds1.maxX < bounds2.minX ||
        bounds2.maxX < bounds1.minX ||
        bounds1.maxY < bounds2.minY ||
        bounds2.maxY < bounds1.minY
      )
    }

    // Update boundary data in the hidden input
    function updateBoundaryData(layer, intersectingCatchment) {
      if (!layer) {
        console.log('No layer provided to updateBoundaryData')
        document.getElementById('boundary-data').value = ''
        return
      }

      const bounds = layer.getBounds()
      const center = bounds.getCenter()
      const latLngs = layer.getLatLngs()[0]
      const points = latLngs.map((latLng) => [latLng.lng, latLng.lat])

      const boundaryData = {
        center: [center.lng, center.lat],
        points: points,
        intersectingCatchment: intersectingCatchment
          ? intersectingCatchment.name
          : null
      }

      document.getElementById('boundary-data').value =
        JSON.stringify(boundaryData)
      console.log('Boundary data updated:', boundaryData)
    }

    // Initialize accessible controls
    function initAccessibleControls(map, drawControl, drawnItems, edpLayers) {
      // Validate required parameters
      if (!map || !drawControl || !drawnItems) {
        console.error('Missing required parameters for initAccessibleControls')
        return
      }

      // Initialize edpLayers as empty array if not provided
      if (!edpLayers) {
        edpLayers = []
        console.log('edpLayers not available, initializing as empty array')
      }

      // Get control elements with null checks
      const startDrawingBtn = document.getElementById('start-drawing')
      const editBoundaryBtn = document.getElementById('edit-boundary')
      const deleteBoundaryBtn = document.getElementById('delete-boundary')
      const zoomToEnglandBtn = document.getElementById('zoom-to-england')
      const zoomToBoundaryBtn = document.getElementById('zoom-to-boundary')
      const toggleCatchmentsBtn = document.getElementById('toggle-catchments')
      const searchInput = document.getElementById('location-search')

      // Check if all required elements exist
      if (
        !startDrawingBtn ||
        !editBoundaryBtn ||
        !deleteBoundaryBtn ||
        !zoomToEnglandBtn ||
        !zoomToBoundaryBtn ||
        !toggleCatchmentsBtn ||
        !searchInput
      ) {
        console.error('One or more control elements not found in DOM')
        return
      }

      let catchmentsVisible = true
      let currentDrawingLayer = null

      // Debug: Check if draw control is properly initialized
      console.log('Draw control object:', drawControl)
      console.log('Draw control toolbars:', drawControl._toolbars)
      if (drawControl._toolbars) {
        console.log('Draw toolbars:', drawControl._toolbars.draw)
        console.log('Edit toolbars:', drawControl._toolbars.edit)
      }

      // Start drawing mode
      startDrawingBtn.addEventListener('click', function (e) {
        e.preventDefault()
        if (isDrawing) {
          // Cancel drawing
          if (currentDrawingLayer) {
            drawnItems.removeLayer(currentDrawingLayer)
            currentDrawingLayer = null
          }
          // Disable drawing mode
          if (
            drawControl._toolbars &&
            drawControl._toolbars.draw &&
            drawControl._toolbars.draw._modes &&
            drawControl._toolbars.draw._modes.polygon
          ) {
            drawControl._toolbars.draw._modes.polygon.handler.disable()
          }
          isDrawing = false
          startDrawingBtn.textContent = 'Start Drawing Boundary'
          startDrawingBtn.classList.remove('govuk-link--destructive')
          console.log('Drawing cancelled')
        } else {
          // Start drawing
          if (
            drawControl._toolbars &&
            drawControl._toolbars.draw &&
            drawControl._toolbars.draw._modes &&
            drawControl._toolbars.draw._modes.polygon
          ) {
            drawControl._toolbars.draw._modes.polygon.handler.enable()
            isDrawing = true
            startDrawingBtn.textContent = 'Cancel Drawing'
            startDrawingBtn.classList.add('govuk-link--destructive')
            console.log('Click on the map to start drawing your boundary')
          } else {
            console.error('Draw control not properly initialized')
            console.error('Error: Drawing control not available')
          }
        }
      })

      // Edit boundary
      editBoundaryBtn.addEventListener('click', function (e) {
        e.preventDefault()
        if (isEditing) {
          // Stop editing
          if (
            drawControl._toolbars &&
            drawControl._toolbars.edit &&
            drawControl._toolbars.edit._modes &&
            drawControl._toolbars.edit._modes.edit
          ) {
            drawControl._toolbars.edit._modes.edit.handler.disable()
          }
          isEditing = false
          editBoundaryBtn.textContent = 'Edit Boundary'
          editBoundaryBtn.classList.remove('govuk-link--destructive')
          console.log('Edit mode disabled')
        } else {
          // Start editing
          if (drawnItems.getLayers().length > 0) {
            if (
              drawControl._toolbars &&
              drawControl._toolbars.edit &&
              drawControl._toolbars.edit._modes &&
              drawControl._toolbars.edit._modes.edit
            ) {
              drawControl._toolbars.edit._modes.edit.handler.enable()
              isEditing = true
              editBoundaryBtn.textContent = 'Stop Editing'
              editBoundaryBtn.classList.add('govuk-link--destructive')
              console.log('Click and drag points to edit your boundary')
            } else {
              console.error('Edit control not properly initialized')
              showErrorSummary(
                'The edit control is not available. Please refresh the page to try again.'
              )
            }
          } else {
            showErrorSummary(
              'No boundary to edit. Please draw a boundary first.'
            )
          }
        }
      })

      // Delete boundary
      deleteBoundaryBtn.addEventListener('click', function (e) {
        e.preventDefault()
        if (drawnItems.getLayers().length > 0) {
          if (confirm('Are you sure you want to delete the boundary?')) {
            drawnItems.clearLayers()
            updateBoundaryData(null, null)
            hideErrorSummary()
            updateLinkStates()
          }
        } else {
          showErrorSummary(
            'No boundary to delete. Please draw a boundary first.'
          )
        }
      })

      // Zoom to England
      zoomToEnglandBtn.addEventListener('click', function (e) {
        e.preventDefault()
        map.setView([52.5, -1.5], 6)
        console.log('Zoomed to show all of England')
      })

      // Zoom to boundary
      zoomToBoundaryBtn.addEventListener('click', function (e) {
        e.preventDefault()
        if (drawnItems.getLayers().length > 0) {
          const group = new L.featureGroup(drawnItems.getLayers())
          map.fitBounds(group.getBounds().pad(0.1))
          hideErrorSummary()
        } else {
          showErrorSummary(
            'No boundary to zoom to. Please draw a boundary first.'
          )
        }
      })

      // Toggle catchments
      toggleCatchmentsBtn.addEventListener('click', function (e) {
        e.preventDefault()
        if (edpLayers && edpLayers.length > 0) {
          catchmentsVisible = !catchmentsVisible
          edpLayers.forEach((edp) => {
            if (catchmentsVisible) {
              map.addLayer(edp.polygon)
            } else {
              map.removeLayer(edp.polygon)
            }
          })
          toggleCatchmentsBtn.textContent = catchmentsVisible
            ? 'Hide Catchments'
            : 'Show Catchments'
          hideErrorSummary()
        } else {
          showErrorSummary(
            'Catchment data is not available. The catchments may still be loading or failed to load.'
          )
        }
      })

      function performSearch(query) {
        if (!query.trim()) {
          showErrorSummary('Please enter a location to search for.')
          return
        }

        hideErrorSummary()
        console.log(`Searching for "${query}"...`)

        setTimeout(() => {
          console.log(
            `Search for "${query}" completed. (Note: This is a demo - integrate with a geocoding service for real functionality)`
          )
          showErrorSummary(
            'Search functionality is not yet implemented. Please use the map controls to navigate.'
          )
        }, 1000)
      }

      searchInput.addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
          performSearch(searchInput.value)
        }
      })

      // Update link states based on current state
      function updateLinkStates() {
        const hasBoundary = drawnItems.getLayers().length > 0

        if (hasBoundary) {
          editBoundaryBtn.removeAttribute('aria-disabled')
          editBoundaryBtn.setAttribute('tabindex', '0')

          deleteBoundaryBtn.removeAttribute('aria-disabled')
          deleteBoundaryBtn.setAttribute('tabindex', '0')

          zoomToBoundaryBtn.removeAttribute('aria-disabled')
          zoomToBoundaryBtn.setAttribute('tabindex', '0')
        } else {
          editBoundaryBtn.setAttribute('aria-disabled', 'true')
          editBoundaryBtn.setAttribute('tabindex', '-1')

          deleteBoundaryBtn.setAttribute('aria-disabled', 'true')
          deleteBoundaryBtn.setAttribute('tabindex', '-1')

          zoomToBoundaryBtn.setAttribute('aria-disabled', 'true')
          zoomToBoundaryBtn.setAttribute('tabindex', '-1')
        }
      }

      // Catchment status updates removed - no status panel needed

      // Handle drawing events with comprehensive error protection
      function setupDrawingEvents() {
        try {
          // Validate all required objects exist and are properly initialized
          if (!map || typeof map.on !== 'function') {
            console.warn('Map object not ready for event listeners')
            return
          }

          if (!L || !L.Draw || !L.Draw.Event) {
            console.warn('Leaflet Draw not available for event listeners')
            return
          }

          // Check if map is fully initialized
          if (!map._container || !map._container.parentNode) {
            console.warn('Map container not ready')
            return
          }

          console.log('Setting up drawing event listeners...')

          // Debug: Log all available Draw events
          console.log('Available Draw events:', Object.keys(L.Draw.Event))
          console.log('DRAWSTART:', L.Draw.Event.DRAWSTART)
          console.log('DRAWVERTEX:', L.Draw.Event.DRAWVERTEX)
          console.log('DRAWCANCEL:', L.Draw.Event.DRAWCANCEL)

          // Track when drawing starts
          if (L.Draw.Event.DRAWSTART) {
            try {
              map.on(L.Draw.Event.DRAWSTART, function (event) {
                console.log('Drawing started:', event)
                console.log(
                  'Drawing started - click on the map to create points'
                )
              })
              console.log('DRAWSTART event listener added successfully')
            } catch (error) {
              console.error('Error adding DRAWSTART event listener:', error)
            }
          } else {
            console.warn('DRAWSTART event not available')
          }

          // Track when drawing is in progress
          if (L.Draw.Event.DRAWVERTEX) {
            try {
              map.on(L.Draw.Event.DRAWVERTEX, function (event) {
                console.log('Vertex added:', event)
                console.log(
                  'Point added - continue clicking to add more points or double-click to finish'
                )
              })
              console.log('DRAWVERTEX event listener added successfully')
            } catch (error) {
              console.error('Error adding DRAWVERTEX event listener:', error)
            }
          } else {
            console.warn('DRAWVERTEX event not available')
          }

          // Track when drawing is cancelled
          if (L.Draw.Event.DRAWCANCEL) {
            try {
              map.on(L.Draw.Event.DRAWCANCEL, function (event) {
                console.log('Drawing cancelled:', event)
                isDrawing = false
                startDrawingBtn.textContent = 'Start Drawing Boundary'
                startDrawingBtn.classList.remove('govuk-link--destructive')
                console.log('Drawing cancelled')
              })
              console.log('DRAWCANCEL event listener added successfully')
            } catch (error) {
              console.error('Error adding DRAWCANCEL event listener:', error)
              console.log(
                'DRAWCANCEL event will be handled through alternative method'
              )
            }
          } else {
            console.warn('DRAWCANCEL event not available')
          }

          // Alternative: Handle drawing cancellation through map click events
          // This is a fallback if DRAWCANCEL doesn't work
          try {
            map.on('click', function (e) {
              // Only handle if we're in drawing mode and user clicks outside
              if (isDrawing) {
                console.log(
                  'Map clicked during drawing - potential cancellation'
                )
                // Note: This is a simplified approach, the actual cancellation
                // will be handled by the drawing controls
              }
            })
            console.log('Alternative drawing cancellation handler added')
          } catch (error) {
            console.error(
              'Error adding alternative cancellation handler:',
              error
            )
          }

          console.log('Drawing event listeners set up successfully')
        } catch (error) {
          console.error('Error setting up drawing event listeners:', error)
        }
      }

      // Set up drawing events with a delay
      setTimeout(setupDrawingEvents, 1000)

      // Handle polygon creation and other events
      function setupPolygonEvents() {
        try {
          // Validate all required objects exist and are properly initialized
          if (!map || typeof map.on !== 'function') {
            console.warn('Map object not ready for polygon event listeners')
            return
          }

          if (!L || !L.Draw || !L.Draw.Event) {
            console.warn(
              'Leaflet Draw not available for polygon event listeners'
            )
            return
          }

          // Check if map is fully initialized
          if (!map._container || !map._container.parentNode) {
            console.warn('Map container not ready for polygon events')
            return
          }

          console.log('Setting up polygon event listeners...')

          // Handle polygon creation
          map.on(L.Draw.Event.CREATED, function (event) {
            console.log('Polygon created event triggered')
            const layer = event.layer
            drawnItems.addLayer(layer)
            currentDrawingLayer = layer
            isDrawing = false
            startDrawingBtn.textContent = 'Start Drawing Boundary'
            startDrawingBtn.classList.remove('govuk-link--destructive')

            hideErrorSummary()
            updateLinkStates()

            // Check for intersections with catchments
            if (edpLayers && edpLayers.length > 0) {
              const drawnPolygon = layer.getLatLngs()[0]
              const drawnPoints = drawnPolygon.map((latLng) => [
                latLng.lng,
                latLng.lat
              ])

              console.log('=== CHECKING INTERSECTIONS FOR DRAWN POLYGON ===')
              console.log(
                'Drawn polygon points (first 3):',
                drawnPoints.slice(0, 3)
              )
              console.log('Total catchments to check:', edpLayers.length)

              let intersectingCatchment = null
              // Check all catchments, not just first 10
              for (let i = 0; i < edpLayers.length; i++) {
                const catchment = edpLayers[i]
                console.log(
                  `Checking catchment ${i + 1}/${edpLayers.length}: ${catchment.name}`
                )

                if (polygonIntersects(drawnPoints, catchment.coordinates)) {
                  intersectingCatchment = catchment
                  console.log(
                    `â INTERSECTION FOUND with catchment: ${catchment.name}`
                  )
                  break // Stop at first intersection found
                } else {
                  console.log(
                    `â No intersection with catchment: ${catchment.name}`
                  )
                }
              }

              updateBoundaryData(layer, intersectingCatchment)

              if (intersectingCatchment) {
                console.log(
                  `â FINAL RESULT: Boundary intersects with catchment: ${intersectingCatchment.name}`
                )
              } else {
                console.log(
                  'â FINAL RESULT: No catchment intersection detected'
                )
              }
              console.log('=== END INTERSECTION CHECK ===')
            } else {
              console.log('No catchment data available for intersection check')
              updateBoundaryData(layer, null)
            }
          })

          // Handle polygon editing
          map.on(L.Draw.Event.EDITED, function (event) {
            console.log('Boundary edited successfully')
            // Re-check intersections after editing (optimized)
            const layers = event.layers
            layers.eachLayer(function (layer) {
              if (edpLayers && edpLayers.length > 0) {
                const drawnPolygon = layer.getLatLngs()[0]
                const drawnPoints = drawnPolygon.map((latLng) => [
                  latLng.lng,
                  latLng.lat
                ])

                let intersectingCatchment = null
                // Limit to first 10 catchments to improve performance
                const catchmentsToCheck = edpLayers.slice(0, 10)

                for (const catchment of catchmentsToCheck) {
                  if (polygonIntersects(drawnPoints, catchment.coordinates)) {
                    intersectingCatchment = catchment
                    break // Stop at first intersection found
                  }
                }

                updateBoundaryData(layer, intersectingCatchment)
              } else {
                updateBoundaryData(layer, null)
              }
            })
          })

          // Handle polygon deletion
          map.on(L.Draw.Event.DELETED, function (event) {
            console.log('Boundary deleted')
            updateLinkStates()
            document.getElementById('boundary-data').value = ''
          })

          // Handle when drawing is completed (polygon is closed)
          map.on(L.Draw.Event.DRAWSTOP, function (event) {
            console.log('Drawing stopped:', event)
            if (isDrawing) {
              console.log('Drawing completed - polygon has been created')
            }
          })

          console.log('Polygon event listeners set up successfully')
        } catch (error) {
          console.error('Error setting up polygon event listeners:', error)
        }
      }

      // Set up polygon events with a delay
      setTimeout(setupPolygonEvents, 1200)

      // Add keyboard event handling for links
      function addKeyboardHandling(linkElement, clickHandler) {
        if (!linkElement) {
          console.warn('Link element is null, skipping keyboard handling')
          return
        }
        linkElement.addEventListener('keydown', function (e) {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault()
            clickHandler(e)
          }
        })
      }

      // Add keyboard handling to all tool links
      addKeyboardHandling(startDrawingBtn, function (e) {
        startDrawingBtn.click()
      })
      addKeyboardHandling(editBoundaryBtn, function (e) {
        editBoundaryBtn.click()
      })
      addKeyboardHandling(deleteBoundaryBtn, function (e) {
        deleteBoundaryBtn.click()
      })
      addKeyboardHandling(zoomToEnglandBtn, function (e) {
        zoomToEnglandBtn.click()
      })
      addKeyboardHandling(zoomToBoundaryBtn, function (e) {
        zoomToBoundaryBtn.click()
      })
      addKeyboardHandling(toggleCatchmentsBtn, function (e) {
        toggleCatchmentsBtn.click()
      })

      // Initialize link states
      updateLinkStates()
    }
  })()
</script>
{% endblock %}
