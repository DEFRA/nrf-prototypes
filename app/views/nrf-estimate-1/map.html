{% extends "govuk-prototype-kit/layouts/govuk-branded.njk" %}

{% set pageName="Draw a red line boundary" %}

{% block pageTitle %}
Draw a red line boundary - Get an estimate for Nature Restoration Fund Levy - GOV.UK
{% endblock %}

{% block head %}
{{ super() }}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
<style>
    .map-container {
        position: relative;
        margin-bottom: 2rem;
    }

    #map {
        height: 500px;
        width: 100%;
        border: 1px solid #b1b4b6;
    }


    /* Minimal Leaflet Draw overrides to work with GOV.UK */
    .leaflet-draw-toolbar {
        border: 2px solid #0b0c0c !important;
        background: white !important;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2) !important;
    }

    .leaflet-draw-toolbar a {
        background-color: white !important;
        border: 1px solid #0b0c0c !important;
        color: #0b0c0c !important;
    }

    .leaflet-draw-toolbar a:hover {
        background-color: #f3f2f1 !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="govuk-width-container">
    <div class="govuk-main-wrapper">
        <div class="govuk-grid-row">
            <div class="govuk-grid-column-full">
                <a href="/nrf-estimate-1/redline-map" class="govuk-back-link">Back</a>

                <form action="/nrf-estimate-1/map" method="post" novalidate>

                    {% if error %}
                    <div class="govuk-error-summary" aria-labelledby="error-summary-title" role="alert">
                        <h2 class="govuk-error-summary__title" id="error-summary-title">
                            There is a problem
                        </h2>
                        <div class="govuk-error-summary__body">
                            <ul class="govuk-list govuk-error-summary__list">
                                <li>
                                    <a href="#map">{{ error }}</a>
                                </li>
                            </ul>
                        </div>
                    </div>
                    {% endif %}

                    <div class="govuk-form-group {% if error %}govuk-form-group--error{% endif %}">
                        <h1 class="govuk-label-wrapper">
                            <label class="govuk-label govuk-label--l" for="map">
                                Draw a red line boundary
                            </label>
                        </h1>

                        <div id="map-hint" class="govuk-hint">
                            <p class="govuk-body">
                                Use the map to draw a red line boundary for where your development might be.
                            </p>
                        </div>

                        {% if error %}
                        <p id="map-error" class="govuk-error-message">
                            <span class="govuk-visually-hidden">Error:</span> {{ error }}
                        </p>
                        {% endif %}

                        <div class="govuk-inset-text">
                            <p class="govuk-body govuk-!-margin-bottom-1">
                                <strong>Instructions:</strong>
                            </p>
                            <ul class="govuk-list govuk-list--bullet govuk-!-margin-bottom-0">
                                <li>Click the polygon tool in the toolbar (top left of map)</li>
                                <li>Click on the map to create points for your development boundary</li>
                                <li>Double-click to finish drawing</li>
                                <li>You can edit or delete your boundary using the toolbar</li>
                            </ul>
                        </div>

                        <div class="map-container">
                            <div id="map">
                                <div id="map-loading"
                                    style="text-align: center; padding: 2rem; background: #f8f8f8; border: 1px solid #ccc;">
                                    <p class="govuk-body">Loading map...</p>
                                </div>
                            </div>
                        </div>

                        <input type="hidden" id="boundary-data" name="boundary-data" value="{{ existingBoundaryData }}">
                    </div>

                    <button class="govuk-button" type="submit">
                        Continue
                    </button>

                </form>
            </div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script>
    // Initialize map after page is fully loaded
    (function () {
        'use strict';

        // Wait for everything to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initMap);
        } else {
            initMap();
        }


        function initMap() {
            // Additional delay to ensure GOV.UK components are ready
            setTimeout(function () {
                console.log('Map script loading...');
                console.log('Leaflet available:', typeof L !== 'undefined');
                console.log('Map container exists:', document.getElementById('map') !== null);

                try {
                    // Hide loading message
                    const loadingDiv = document.getElementById('map-loading');
                    if (loadingDiv) {
                        loadingDiv.style.display = 'none';
                    }

                    // Initialize the map centered on England
                    const map = L.map('map').setView([52.5, -1.5], 6);
                    console.log('Map initialized');

                    // Add OpenStreetMap tiles
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: 'Â© OpenStreetMap contributors'
                    }).addTo(map);
                    console.log('Tiles added');

                    // Load GeoJSON boundaries
                    let edpBoundaries = [];
                    let edpLayers = [];

                    // Color palette for different catchments
                    const colors = [
                        "#ff6b6b", "#4ecdc4", "#45b7d1", "#96ceb4",
                        "#feca57", "#ff9ff3", "#a8e6cf", "#dda0dd",
                        "#ffa726", "#ab47bc", "#26a69a", "#42a5f5",
                        "#66bb6a", "#ef5350", "#ff7043", "#8d6e63"
                    ];

                    // Load GeoJSON data
                    console.log('=== STARTING GEOJSON LOAD ===');
                    fetch('/nrf-estimate-1/catchments.geojson')
                        .then(response => {
                            console.log('Fetch response status:', response.status);
                            console.log('Fetch response ok:', response.ok);
                            return response.json();
                        })
                        .then(data => {
                            console.log('GeoJSON data loaded successfully');
                            console.log('Number of features:', data.features ? data.features.length : 'undefined');
                            console.log('First feature:', data.features ? data.features[0] : 'undefined');

                            // Process each feature in the GeoJSON
                            data.features.forEach((feature, index) => {
                                const properties = feature.properties;
                                const geometry = feature.geometry;

                                // Extract catchment name from properties
                                const catchmentName = properties.Label || properties.N2K_Site_N || `Catchment ${index + 1}`;
                                const color = colors[index % colors.length];

                                // Convert GeoJSON coordinates to Leaflet format
                                if (geometry.type === 'Polygon') {
                                    const coordinates = geometry.coordinates[0].map(coord => [coord[1], coord[0]]); // Convert [lng, lat] to [lat, lng]

                                    // Debug logging for first few catchments
                                    if (index < 3) {
                                        console.log(`Catchment ${index + 1} (${catchmentName}):`);
                                        console.log('  Original GeoJSON coords (first 3):', geometry.coordinates[0].slice(0, 3));
                                        console.log('  Converted Leaflet coords (first 3):', coordinates.slice(0, 3));
                                        console.log('  Coordinate count:', coordinates.length);
                                    }

                                    const polygon = L.polygon(coordinates, {
                                        color: color,
                                        weight: 2,
                                        opacity: 0.8,
                                        fillColor: color,
                                        fillOpacity: 0.3
                                    }).addTo(map);

                                    // Add popup with catchment information
                                    const popupContent = `
                                        <strong>${catchmentName}</strong><br>
                                        ${properties.PopupInfo ? `Type: ${properties.PopupInfo}<br>` : ''}
                                        ${properties.DateAmend ? `Last Updated: ${properties.DateAmend}<br>` : ''}
                                        ${properties.Notes ? `Notes: ${properties.Notes}` : ''}
                                    `;
                                    polygon.bindPopup(popupContent);

                                    edpLayers.push({
                                        name: catchmentName,
                                        polygon: polygon,
                                        coordinates: coordinates,
                                        properties: properties
                                    });

                                    edpBoundaries.push({
                                        name: catchmentName,
                                        color: color,
                                        coordinates: coordinates
                                    });
                                }
                            });

                            console.log('Catchment boundaries added:', edpLayers.length);

                            // Test intersection function with a simple case
                            if (edpLayers.length > 0) {
                                console.log('=== TESTING INTERSECTION FUNCTION ===');
                                const testPolygon1 = [[-2.9, 52.2], [-2.8, 52.2], [-2.8, 52.3], [-2.9, 52.3], [-2.9, 52.2]];
                                const testPolygon2 = [[-2.85, 52.25], [-2.75, 52.25], [-2.75, 52.35], [-2.85, 52.35], [-2.85, 52.25]];
                                const testResult = polygonIntersects(testPolygon1, testPolygon2);
                                console.log('Test intersection result:', testResult);

                                // Test with actual catchment coordinates if available
                                if (edpLayers.length > 0) {
                                    console.log('Testing with actual catchment data...');
                                    const firstCatchment = edpLayers[0];
                                    console.log('First catchment name:', firstCatchment.name);
                                    console.log('First catchment coords (first 3):', firstCatchment.coordinates.slice(0, 3));

                                    // Create a test polygon that should intersect with the first catchment
                                    const testDrawnPolygon = firstCatchment.coordinates.slice(0, 4); // Use first 4 points of catchment
                                    const testResult2 = polygonIntersects(testDrawnPolygon, firstCatchment.coordinates);
                                    console.log('Test with actual catchment data result:', testResult2);

                                    // Test with coordinates from your drawn area
                                    const testPolygon3 = [[-1.9, 51.2], [-1.8, 51.2], [-1.8, 51.3], [-1.9, 51.3], [-1.9, 51.2]];
                                    console.log('Testing with coordinates from drawn area:', testPolygon3);
                                    const testResult3 = polygonIntersects(testPolygon3, firstCatchment.coordinates);
                                    console.log('Test with drawn area coordinates result:', testResult3);
                                }

                                console.log('=== END TEST ===');

                                // Re-check any existing drawn polygons for intersections
                                console.log('Re-checking existing drawn polygons for intersections...');
                                drawnItems.eachLayer(function (layer) {
                                    if (layer instanceof L.Polygon) {
                                        console.log('Re-checking existing polygon for intersections');
                                        const drawnPolygon = layer.getLatLngs()[0];
                                        const drawnPoints = drawnPolygon.map(latLng => [latLng.lng, latLng.lat]);

                                        let intersectingCatchment = null;
                                        edpLayers.forEach(catchment => {
                                            if (polygonIntersects(drawnPoints, catchment.coordinates)) {
                                                intersectingCatchment = catchment;
                                                console.log(`Found intersection with existing polygon: ${catchment.name}`);
                                            }
                                        });

                                        updateBoundaryData(layer, intersectingCatchment);
                                    }
                                });
                            }

                            // Fit map to show all boundaries
                            if (edpLayers.length > 0) {
                                const group = new L.featureGroup(edpLayers.map(edp => edp.polygon));
                                map.fitBounds(group.getBounds().pad(0.1));
                                console.log('Map fitted to show catchment boundaries');
                            }
                        })
                        .catch(error => {
                            console.error('=== GEOJSON LOAD ERROR ===');
                            console.error('Error loading GeoJSON data:', error);
                            console.error('Error message:', error.message);
                            console.error('Error stack:', error.stack);
                            console.log('Falling back to hardcoded boundaries');
                            console.log('=== END GEOJSON LOAD ERROR ===');
                        });


                    // Initialize the draw control
                    const drawnItems = new L.FeatureGroup();
                    map.addLayer(drawnItems);

                    const drawControl = new L.Control.Draw({
                        position: 'topleft',
                        draw: {
                            polygon: {
                                allowIntersection: false,
                                showArea: true,
                                drawError: {
                                    color: '#e1e100',
                                    message: '<strong>Error:</strong> shape edges cannot cross!'
                                },
                                shapeOptions: {
                                    color: '#d4351c',
                                    weight: 3,
                                    opacity: 0.8,
                                    fillColor: '#d4351c',
                                    fillOpacity: 0.2
                                }
                            },
                            polyline: false,
                            rectangle: false,
                            circle: false,
                            marker: false,
                            circlemarker: false
                        },
                        edit: {
                            featureGroup: drawnItems,
                            remove: true
                        }
                    });
                    map.addControl(drawControl);
                    console.log('Draw control added');

                    // Add a simple click handler to test if events are working
                    map.on('click', function (e) {
                        console.log('Map clicked at:', e.latlng);
                    });

                    // Load existing boundary data if available
                    const existingBoundaryData = document.getElementById('boundary-data').value;
                    console.log('Raw boundary data from input:', existingBoundaryData);

                    if (existingBoundaryData) {
                        try {
                            const boundaryData = JSON.parse(existingBoundaryData);
                            console.log('Parsed boundary data:', boundaryData);
                            console.log('Coordinates:', boundaryData.coordinates);
                            console.log('Coordinates type:', typeof boundaryData.coordinates);
                            console.log('Is array:', Array.isArray(boundaryData.coordinates));

                            // Check if coordinates exist and convert to Leaflet format
                            if (boundaryData.coordinates && Array.isArray(boundaryData.coordinates) && boundaryData.coordinates.length > 0) {
                                console.log('Processing coordinates...');
                                const latLngs = boundaryData.coordinates.map(point => [point[1], point[0]]); // Convert [lng, lat] to [lat, lng]
                                console.log('Converted latLngs:', latLngs);

                                // Create and add the existing polygon
                                const existingPolygon = L.polygon(latLngs, {
                                    color: '#d4351c',
                                    weight: 3,
                                    opacity: 0.8,
                                    fillColor: '#d4351c',
                                    fillOpacity: 0.2
                                });

                                drawnItems.addLayer(existingPolygon);

                                // Fit map to show the existing boundary
                                map.fitBounds(existingPolygon.getBounds().pad(0.1));

                                console.log('Existing boundary loaded and displayed successfully');
                            } else {
                                console.log('No valid coordinates found in boundary data. Coordinates:', boundaryData.coordinates);
                            }
                        } catch (error) {
                            console.error('Error loading existing boundary:', error);
                            console.error('Raw data that failed to parse:', existingBoundaryData);
                        }
                    } else {
                        console.log('No existing boundary data found');
                    }

                    // Handle drawing events
                    map.on(L.Draw.Event.CREATED, function (event) {
                        console.log('=== POLYGON CREATED EVENT ===');
                        console.log('Polygon created');
                        console.log('edpLayers length:', edpLayers.length);
                        console.log('edpLayers available:', edpLayers.length > 0);

                        const layer = event.layer;
                        drawnItems.addLayer(layer);

                        // Check if catchments are loaded
                        if (edpLayers.length === 0) {
                            console.log('WARNING: No catchments loaded yet, skipping intersection check');
                            updateBoundaryData(layer, null);
                            return;
                        }

                        // Check if the drawn polygon intersects with any catchment boundary
                        const drawnPolygon = layer.getLatLngs()[0];
                        const drawnPoints = drawnPolygon.map(latLng => [latLng.lng, latLng.lat]); // Convert to [lng, lat] format

                        console.log('=== INTERSECTION DEBUG ===');
                        console.log('Drawn polygon points:', drawnPoints);
                        console.log('Number of catchments to check:', edpLayers.length);
                        console.log('First few catchments:', edpLayers.slice(0, 3).map(c => ({name: c.name, coordsLength: c.coordinates.length})));

                        let intersectingCatchment = null;
                        edpLayers.forEach((catchment, index) => {
                            console.log(`Checking catchment ${index + 1}: ${catchment.name}`);
                            console.log(`Catchment coordinates length: ${catchment.coordinates.length}`);
                            console.log(`First few catchment coords:`, catchment.coordinates.slice(0, 3));

                            const intersects = polygonIntersects(drawnPoints, catchment.coordinates);
                            console.log(`Intersects with ${catchment.name}:`, intersects);

                            if (intersects) {
                                intersectingCatchment = catchment;
                                console.log(`FOUND INTERSECTION: ${catchment.name}`);
                            }
                        });

                        console.log('Final intersecting catchment:', intersectingCatchment ? intersectingCatchment.name : 'null');
                        console.log('=== END INTERSECTION DEBUG ===');

                        // Update the boundary data
                        updateBoundaryData(layer, intersectingCatchment);
                    });

                    map.on(L.Draw.Event.EDITED, function (event) {
                        console.log('Polygon edited');
                        const layers = event.layers;
                        layers.eachLayer(function (layer) {
                            const drawnPolygon = layer.getLatLngs()[0];
                            const drawnPoints = drawnPolygon.map(latLng => [latLng.lng, latLng.lat]); // Convert to [lng, lat] format

                            let intersectingCatchment = null;
                            edpLayers.forEach(catchment => {
                                if (polygonIntersects(drawnPoints, catchment.coordinates)) {
                                    intersectingCatchment = catchment;
                                }
                            });

                            updateBoundaryData(layer, intersectingCatchment);
                        });
                    });

                    map.on(L.Draw.Event.DELETED, function (event) {
                        console.log('Polygon deleted');
                        document.getElementById('boundary-data').value = '';
                    });

                    // Helper function to check if a point is within a polygon
                    function isPointInPolygon(point, polygon) {
                        const x = point[0], y = point[1]; // point is [lng, lat]
                        console.log(`Checking point [${x}, ${y}] against polygon with ${polygon.length} vertices`);
                        console.log(`Polygon sample: [${polygon[0][0]}, ${polygon[0][1]}], [${polygon[1][0]}, ${polygon[1][1]}]`);

                        let inside = false;
                        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                            // polygon coordinates are [lng, lat] format
                            const xi = polygon[i][0], yi = polygon[i][1]; // [lng, lat]
                            const xj = polygon[j][0], yj = polygon[j][1]; // [lng, lat]
                            if (((yi > y) !== (yj > y)) &&
                                (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                                inside = !inside;
                            }
                        }
                        console.log(`Point [${x}, ${y}] inside polygon: ${inside}`);
                        return inside;
                    }

                    // Helper function to check if two polygons intersect
                    function polygonIntersects(polygon1, polygon2) {
                        console.log('polygonIntersects called with:');
                        console.log('polygon1 length:', polygon1.length);
                        console.log('polygon2 length:', polygon2.length);
                        console.log('polygon1 sample:', polygon1.slice(0, 2));
                        console.log('polygon2 sample (before conversion):', polygon2.slice(0, 2));

                        // Convert polygon2 coordinates from [lat, lng] to [lng, lat] format
                        const poly2 = polygon2.map(coord => [coord[1], coord[0]]);
                        console.log('poly2 (converted) length:', poly2.length);
                        console.log('poly2 sample (after conversion):', poly2.slice(0, 2));

                        // Simplified approach: check if any vertex of polygon1 is inside polygon2
                        // This is more reliable than complex edge intersection algorithms
                        for (let i = 0; i < polygon1.length; i++) {
                            const inside = isPointInPolygon(polygon1[i], poly2);
                            console.log(`Checking vertex ${i} [${polygon1[i][0]}, ${polygon1[i][1]}] inside polygon2: ${inside}`);
                            if (inside) {
                                console.log(`Vertex ${i} of polygon1 is inside polygon2`);
                                return true;
                            }
                        }

                        // Also check if any vertex of polygon2 is inside polygon1
                        for (let i = 0; i < poly2.length; i++) {
                            const inside = isPointInPolygon(poly2[i], polygon1);
                            if (inside) {
                                console.log(`Vertex ${i} of polygon2 is inside polygon1`);
                                return true;
                            }
                        }

                        // Check center point of polygon1
                        const centerLng = polygon1.reduce((sum, coord) => sum + coord[0], 0) / polygon1.length;
                        const centerLat = polygon1.reduce((sum, coord) => sum + coord[1], 0) / polygon1.length;
                        const centerInside = isPointInPolygon([centerLng, centerLat], poly2);
                        console.log(`Center point [${centerLng}, ${centerLat}] inside polygon2: ${centerInside}`);
                        if (centerInside) {
                            console.log('Center point of polygon1 is inside polygon2');
                            return true;
                        }

                        console.log('No intersection found');
                        return false;
                    }

                    // Helper function to check if two line segments intersect
                    function lineSegmentsIntersect(p1, q1, p2, q2) {
                        function orientation(p, q, r) {
                            const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
                            if (val === 0) return 0; // collinear
                            return val > 0 ? 1 : 2; // clockwise or counterclockwise
                        }

                        function onSegment(p, q, r) {
                            return q[0] <= Math.max(p[0], r[0]) && q[0] >= Math.min(p[0], r[0]) &&
                                q[1] <= Math.max(p[1], r[1]) && q[1] >= Math.min(p[1], r[1]);
                        }

                        const o1 = orientation(p1, q1, p2);
                        const o2 = orientation(p1, q1, q2);
                        const o3 = orientation(p2, q2, p1);
                        const o4 = orientation(p2, q2, q1);

                        // General case
                        if (o1 !== o2 && o3 !== o4) return true;

                        // Special cases
                        if (o1 === 0 && onSegment(p1, p2, q1)) return true;
                        if (o2 === 0 && onSegment(p1, q2, q1)) return true;
                        if (o3 === 0 && onSegment(p2, p1, q2)) return true;
                        if (o4 === 0 && onSegment(p2, q1, q2)) return true;

                        return false;
                    }

                    // Update boundary data in the hidden input
                    function updateBoundaryData(layer, intersectingCatchment) {
                        const bounds = layer.getBounds();
                        const center = bounds.getCenter();
                        const latLngs = layer.getLatLngs()[0];
                        const points = latLngs.map(latLng => [latLng.lng, latLng.lat]);

                        const boundaryData = {
                            center: [center.lng, center.lat],
                            points: points,
                            intersectingCatchment: intersectingCatchment ? intersectingCatchment.name : null
                        };

                        document.getElementById('boundary-data').value = JSON.stringify(boundaryData);
                        console.log('Boundary data updated:', boundaryData);
                    }

                    // Form submission validation
                    document.querySelector('form').addEventListener('submit', function (e) {
                        const boundaryData = document.getElementById('boundary-data').value;
                        if (!boundaryData) {
                            e.preventDefault();
                            alert('Please draw a boundary on the map before continuing.');
                            return false;
                        }
                    });

                    console.log('Map setup complete');
                } catch (error) {
                    console.error('Error initializing map:', error);
                    const loadingDiv = document.getElementById('map-loading');
                    if (loadingDiv) {
                        loadingDiv.innerHTML = '<p class="govuk-body" style="color: red;">Error loading map. Please refresh the page.</p>';
                    }
                }
            }, 1000); // Increased delay to ensure GOV.UK components are ready
        }
    })();
</script>
{% endblock %}